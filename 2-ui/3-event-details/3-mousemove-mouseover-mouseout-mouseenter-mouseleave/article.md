# حرکت موس: روی/بیرون‌از عنصر، ورود/خروج‌از عنصر

اکنون درباره رویدادهایی که با حرکت موس بین عناصر صفحه اتفاق می‌افتد، بیشتر صحبت میکنیم.

## رویدادهای mouseover/mouseout, relatedTarget

رویداد `mouseover` زمانی اتفاق می‌افتد که اشاره‌گر موس روی یک عنصر می‌رود, و `mouseout` -- زمانی که از روی آن بیرون می‌رود.

![](mouseover-mouseout.svg)

این‌ها رویدادهای خاصی هستند، زیرا یک خاصیت به نام `relatedTarget` دارند. این خاصیت به نوعی مکمل `target` خواهد بود. زمانی که اشاره‌گر موس یک عنصر را با ورودی به عنصر دیگر ترک می‌کند، یکی از آن‌ها `target`، و دیگری `relatedTarget` خواهد بود.

برای `mouseover`:

- `event.target` -- عنصری خواهدبود که اشاره‌گر موس روی آن رفته‌است.
- `event.relatedTarget` -- عنصری خواهد بود که اشاره‌گر موس آنرا ترک کرده، به صورت: (`relatedTarget` -> `target`).

برای `mouseout` برعکس است:

- `event.target` -- عنصری خواهد بود که اشاره‌گر موس آنرا ترک‌کرده.
- `event.relatedTarget` -- عنصری خواهد بود که زیر اشاره‌گر موس قرار می‌گیرد، به صورت: (`target` -> `relatedTarget`).

```online
در مثال زیر هر چهره و اجزای آن عناصر جداگانه هستند. زمانی که اشاره‌گر موس‌ را روی آن‌ها حرکت دهید، رویدادهایی که اتفاق می‌افتند را مشاهده خواهید کرد.

هر رویداد اطلاعاتی درباره هر دو `target` و `relatedTarget` دارد:

[codetabs src="mouseoverout" height=280]
```

```warn header="`relatedTarget` می‌تواند `null` باشد"
خاصیت `relatedTarget` می‌تواند است `null` باشد.

این عادی است و فقط به این معنی است که اشاره‌گر موس از عنصر دیگری نیامده، بلکه از خارج از پنجره مرورگر وارد شده. یا اینکه با خارج شدن، از پنجره مرورگر خارج شده.

ما باید این احتمال را هنگام استفاده از `event.realtedTarget` در کد به یاد داشته باشیم. اگر ما سعی کنیم که `event.relatedTarget.tagName` دسترسی پیدا کنیم، با خطا مواجه خواهیم شد.
```

## پرش از روی عناصر

رویداد `mousemove` زمانی اتفاق می‌افتد که اشاره‌گر موس حرکت کند. اما به این معنی نیست که برای هر پیکسل این رویداد اتفاق بیفتد.

مرورگر موقعیت اشاره‌گر موس را هرچند وقت بسیار کوتاه یکبار چک می‌کند. و اگر تغییری را ببیند رویداد را صدا می‌زند.

به این معنی که اگر بازدیدکننده موس را سریع حرکت دهد، ممکن است بعضی از عناصر داخل DOM از قلم بیفتند:

![](mouseover-mouseout-over-elems.svg)

اگر که موس از `#FROM` سریعا به `#TO` حرکت کند، مانند شکل بالا، عناصر `<div>` وسطی (یا بعضی از آن‌ها) ممکن‌است از قلم بیفتند. رویداد `mouseout` ممکن است روی `#FROM` و بعد از آن سریعا `mouseover` روی `#TO` اتفاق بیفتد.

این برای کارایی برنامه خوب است، چون ممکن است از روی تعداد زیاد عنصر بین دو عنصر عبور کند. در عمل معمولا نمی‌خواهیم همه‌ای این ورود و خروج از تک تک عناصر را پردازش کنیم.

از طرف دیگر، باید در نظر داشته باشیم که اشاره‌گر موس همیشه همه‌ی عناصر را در طول مسیر حرکتش "ملاقات" نمی‌کند. ممکن است "پرش" کند.

در حالت خاصی، ممکن است که اشاره‌گر موس از بیرون از پنجره مرورگر، دقیقا داخل یک عنصر پرش کند. در این حالت `realtedTarget` مقدار `null` خواهد داشت، چون اشاره‌گر عملا از "ناکجا آباد" آمده است:

![](mouseover-mouseout-from-outside.svg)

```online
می‌توانید این رفتار را به صورت زنده در قسمت آزمایشی زیر ببینید.

کد اچ‌تی‌ام‌ال دارای دو عنصر تو در تو است: عنصر `<div id="child">` داخل عنصر `<div id="parent">` قرار گرفته است. اگر که اشاره‌گر موس را سریعا روی آنها حرکت دهید، ممکن است که فقط عنصر فرزند رویداد را صدا بزند، یا شاید عنصر پدر، حتی ممکن است اصلا رویداد اتفاق نیفتد.

همچنین اشاره‌گر را داخل `div` فرزند ببرید، و سپس آنرا از روی عنصر پدر، با پایین بردن اشاره‌گر از روی عنصر فرزند خارج کنید. اگر حرکت به اندازه کافی سریع باشد، عنصر پدر نادیده گرفته خواهد شد. اشاره‌گر موس از روی عنصر پدر بدون توجه به آن عبور می‌کند.

[codetabs height=360 src="mouseoverout-fast"]
```

```smart header="اگر `mouseover` اتفاق بیفتد, حتما `mouseout` اتفاق خواهد افتاد"
در صورت حرکت سریع اشاره‌گر موس، عناصر بین حرکت ممکن است نادیده گرفته‌‌شوند، اما چیزی که از آن مطمئن هستیم این است که: اگر اشاره‌گر موس "رسما" وارد یک عنصر شود (رویداد `mouseover` اتفاق بیفتند)، هنگام ترک این عنصر همیشه رویداد `mouseout` نیز اتفاق خواهد افتاد.
```

## رویداد mouseout وقتی اشاره‌گر وارد عنصر فرزند می‌شود

یک ویژگی مهم `mouseout` این است که زمانی که از یک عنصر به فرزندان آن برویم، اتفاق می‌افتد. برای مثال در اچ‌تی‌ام‌ال زیر زمانی که از `#parent` به `#child` برویم:

```html
<div id="parent">
  <div id="child">...</div>
</div>
```

اگر روی `#parent` باشیم و سپس اشاره‌گر موس را داخل‌تر و داخل `#child` ببریم، رویداد `mouseout` روی `#parent` اتفاق می‌افتد.

![](mouseover-to-child.svg)

ممکن‌ است عجیب باشد، اما به سادگی شرح داده می‌شود.

**با توجه به منطق مرورگر، اشاره گر موس این امکان را دارد که فقط بالای *یک* عنصر در یک زمان واحد باشد. داخلی‌ترین و بالاترین به واسطه z-index.**

پس اگر داخل یک عنصر دیگر (حتی فرزند) شود، پس از قبلی بیرون می‌رود.

به این نکته دیگر درباره جزئیات پردازش رویدادها دقت کنید.

رویداد `mouseover` زمانی که روی یک فرزند اتفاق بیفتد، به اطلاح بالا می‌رود. به این معنی که اگر `parent` یک کنترل‌کننده برای رویداد `mouseover` داشته باشد، فراخوانی ‌می‌شود:

![](mouseover-bubble-nested.svg)

```online
در مثال زیر به خوبی می‌توانید ببینید: `<div id="child">` داخل `<div id="parent">` قرار دارد. برای رویدادهای `mouseover/out` کنترل‌کننده‌هایی روی `#parent` تعریف شده که جزئیاتی درباره رویداد را در خروجی نمایش می‌دهد.

اگر اشاره‌گر موس را از روی `#parent` حرکت دهید و روی `#child` ببرید، دو رویداد را روی `#parent` خواهید دید:
1. `mouseout [target: parent]` (ترک پدر), سپس
2. `mouseover [target: child]` (ورود به فرزند, اصطلاحا بالا رفته).

[codetabs height=360 src="mouseoverout-child"]
```

همانطور که نشان داده‌شد، زمانی که اشاره‌گر موس از `#parent` بیرون و روی `#child` می‌رود، هر دو کنترل کننده پدر فراخوانده می‌شوند: `mouseout` و `mouseover`:

```js
parent.onmouseout = function(event) {
  /* event.target: عنصر پدر */
};
parent.onmouseover = function(event) {
  /* event.target: عنصر فرزند (اصطلاحا بالا رفته) */
};
```

**اگر که `event.target` را داخل کنترل‌کننده‌ها بررسی نکنیم، به نظر می‌رسد که موس `#parent` را ترک‌ کرده و سپس سریعا روی آن برگشته است.**

اما این‌گونه نیست! اشاره‌گر موس هنوز روی عنصر پدر قراردارد، فقط وارد وارد عنصر فرزند  که داخلی‌تر است شده.

اگر زمان خروج از عنصر پدر قرار است، کاری انجام شود، برای مثال انیمیشنی در زمان `parent.onmouseout` اجرا شود، معمولا نمیخواهیم که زمانی که موس داخل عناصر داخلی‌تر `#parent` می‌شود، این کار انجام شود.

برای جلوگیری از این رفتار، ما `relatedTarget` را در کنترل کننده چک می‌کنیم. اگر که اشاره‌گر موس هنوز داخل عنصر بود، پس صرفا رویداد را نادیده می‌گیریم.

می‌توانیم از دو رویداد دیگر نیز استفاده کنیم: `mouseenter` و `mouseleave`، که اکنون به آنها می‌پردازیم،‌ چنین مشکلاتی را باعث نمی‌شوند.

## رویدادهای mouseenter و mouseleave

رویدادهای `mouseenter/mouseleave` مشابه `mouseover/mouseout` هستند. زمانی اتفاق می‌افتند که اشاره‌گر وارد یک عنصر، یا از آن خارج می‌شود.

اما دو تفاوت اساسی وجود دارد:

1. گذرهای داخل عنصر، از\به فرزندها در نظر گرفته ‌نمی‌شوند.
2. رویداد‌های `mouseenter/mouseleave` به اصطلاح بالا نمی‌روند.

این رویدادها بسیار ساده هستند.

زمانی که اشاره‌گر موش وارد یک عنصر شود، ‍`mouseenter` اتفاق می‌افتد. محل دقیق اشاره‌گر داخل عنصر یا فرزندهای آن مهم نیست.

زمانی که اشاره‌گر از یک عنصر خارج شود، `mouseleave` اتفاق می‌افتد.

```online
این مثال شبیه بالایی است، اما عنصر پدر به رویدادهای `mouseenter/mouseleave` به جای `mouseover/mouseout` گوش می‌دهد.

همانطور که می‌بینید، تنها رویدادهایی که ایجاد می‌شوند،‌آنهایی هستند که به واسطه ورود و خروج اشاره‌گر موس از عنصر پدر اتفاق می‌افتند. زمانی که اشاره‌گر موس وارد عنصر فرزند و از آن خارج می‌شود اتفاقی نمی‌افتد. گذرهایی بین فرزندها اتفاق می‌افتد نادیده گرفته می‌شوند.

[codetabs height=340 src="mouseleave"]
```

## واگذاری رویداد

رویدادهای `mouseenter/leave` بسیار ساده و برای استفاده ساده هستند. اما بالا نمی‌روند. پس نمی‌تواتیم برای آنها از واگذاری رویدادها استفاده کنیم.

تصور کنید که می‌خواهیم ورود/خروج اشاره‌گر موس برای سلول‌های جدول کنترل کنیم. و صدها سلول وجود دارد.

طبیعتا راه حلی که ابتدا به ذهن می‌رسد این است که کنترل‌کننده را روی `<table>` تنظیم کنیم و رویدادها را درون آن پردازش کنیم. اما رویدادهای `mouseenter/leave` بالا نمی‌روند. پس اگر چنین رویدادی روی `<td>` اتفاق بیفتد، فقط کنترل‌کننده‌ای که روی آن `<td>` می‌تواند متوجه این رویداد شود.

کنترل‌کننده‌هایی که برای `mouseenter/leave` روی `<table>` وجود دارند، تنها زمانی صدا زده‌ ‌می‌شوند که اشاره‌گر موس وارد/خارج جدول کلی شود. در این صورت گرفتن اطلاعات درباره گذرهایی که درون خود جدول اتفاق می‌افتد غیر ممکن خواهد بود.

پس، از `mouseover/mouseout` استفاده می‌کنیم.

با یک کنترل‌کننده ساده که تنها عنصر زیر اشاره‌گر موس را مشخص می‌کند شروع کنیم:

```js
// مشخص کردن عنصر زیر اشاره‌گر موس
table.onmouseover = function(event) {
  let target = event.target;
  target.style.background = 'pink';
};

table.onmouseout = function(event) {
  let target = event.target;
  target.style.background = '';
};
```

```online
در اینجا می‌توانید چیزی که اتفاق می‌افتد را ببینید. با حرکت اشاره‌گر موس روی عناصر این جدول، عنصر کنونی که زیر اشاره‌گر موس است مشخص می‌شود:

[codetabs height=480 src="mouseenter-mouseleave-delegation"]
```

در این حالت ما می‌خواستیم که گذرهایی که بین سلول‌های جدول `<td>` اتفاق می‌افتد را کنترل کنیم: ورود به یک سلول جدول و خروج از آن. بقیه‌ی گذرها، مانند درون یک سلول، یا خارج هر سلول، به ما کمکی نمی‌کند. پس بیایید آنها را پالایش کنیم.

کاری که می‌توانیم انجام دهیم این است:

- عنصر کنونی مشخص شده `<td>` را درون یک متغیر ذخیره کنیم. آنرا `currentElem` می‌نامیم.
- در هنگام `mouseover`، رویداد را در صورتی که هنوز داخل عنصر `<td>` کنونی باشیم، نادیده می‌گیریم.
- در هنگام `mouseout`، رویداد را در صورتی که عنصر `<td>` کنونی را ترک نکرده باشیم، نادیده می‌گیریم.

این مثال تمام حالاتی که ممکن است اتفاق بیفتند حساب کرده است:

[js src="mouseenter-mouseleave-delegation-2/script.js"]

بار دیگر، ویژگی‌های مهم عبارت‌اند از:
1. برای کنترل ورود/خروج اشاره‌گر موس از هر `<td>` درون جدول، از واگذاری رویداد استفاده می‌شود. پس از `mouseover/out` بجای `mouseenter/leave` برای این منظور استفاده می‌شود.
2. رویدادهای اضافی، مانند حرکت موس بین فرزندهای خود `<td>` پالایش شده‌اند، به طوری که `onEnter/Leave` تنها زمانی اجرا می‌شوند که اشاره‌گر موس وارد/خارج کل `<td>` شود.

```online
در اینجا مثال کاملی همراه با تمام جزئیات آمده است:

[codetabs height=460 src="mouseenter-mouseleave-delegation-2"]

اشاره‌گر موس را رو و بیرون سلول‌های جدول ببرید. سریع یا آسان، اهمیتی ندارد. کل `<td>` مشخص خواهد شد، برخلاف مثالی که قبلا دیده بودیم.
```

## خلاصه

ما درباره رویدادهای `mouseover`، `mouseout`، `mousemove`، `mouseenter` و `mouseleave` صحبت کردیم.

توجه به این نکات خوب است که:

- یک حرکت سریع موس ممکن است باعث پرش از روی عناصر بین حرکت شود.
- رویدادهای `mouseover/out` و `mouseenter/leave` یک خاصیت اضافی دارند: `relatedTarget`. که عنصری خواهد بود که وارد/خارج آن می‌شویم، و به نوعی مکمل `target` است.

رویدادهای `mouseover/out` زمانی که ما از عنصر پدر به فرزند برویم هم اتفاق می‌افتند. مرورگر فرض می‌کند که اشاره‌گر موس در یک زمان فقط می‌تواند روی یک عنصر باشد، داخلی‌ترین عنصر.

اما رویدادهای `mouseenter/leave‍` از این نظر متفاوت عمل می‌کنند: آنها فقط زمانی اتفاق می‌افتند که اشاره‌گر موس وارد یا یک عنصر به عنوان یک کل خارج شود. همچنین آنها اصطلاحا، بالا نمی‌روند.
