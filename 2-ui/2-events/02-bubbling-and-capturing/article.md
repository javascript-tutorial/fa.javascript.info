# بالارفتن و گرفتن

با یک مثال شروع می‌کنیم.

این کنترل‌کننده به `<div>` اختصاص داده شده، اما در صورتی که هر تگ داخل آنرا مانند `<em>` یا `<code>` کلیک کنید، باز هم اجرا می‌شود:

```html autorun height=60
<div onclick="alert('کنترل‌کننده!')">
  <em>اگر روی <code>EM</code> کلیک کنید، کنترل‌کننده روی <code>DIV</code> اجرا می‌شود.</em>
</div>
```

این رفتار کمی عجیب نیست؟ چرا کنترل‌کننده‌ی روی `<div>` باید زمانی اجرا شود که کلیک در اصل روی `<em>` بوده است؟

## بالا رفتن حبابی

رفتار بالارفتن حبابی ساده است.

**وقتی که رویدادی روی یک عنصر اتفاق می‌افتد، اول کنترل‌کننده‌ها را روی خودش اجرا می‌کند، بعد روی عنصر پدرش اجرا می‌کند، و همینطور تا بالاترین اجداد آن.**

فرض کنیم که سه عنصر تو در تو به صورت ‍`FORM > DIV > P` با یک کنترل‌کننده روی هر کدام از آن‌ها داشته باشیم:

```html run autorun
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

یک کلیک روی `<p>` اول باعث فراخوانی `onlick` به صورت زیر می‌شود:
1. روی `<p>`.
2. روی `<div>` بیرونی.
3. روی `<form>` بیرونی.
4. همینطور بالا می‌رود تا روی شئ `document` هم اجرا شود.

![](event-order-bubbling.svg)

پس اگر روی `<p>` کلیک کنیم، سه پیام به صورت روبرو مشاهده می‌کنیم: `p` -> `div` -> `form`.

این روند اصلاحا "بالارفتن حبابی" یا "bubbling" است، چون رویدادها از داخلی‌ترن عنصر تا عنصرهای والد مانند یک حباب در آب، بالا می‌روند.

```warn header="*تقریبا* همه رویدادها بالا می‌روند."
کلمه کلیدی در این جمله "تقریبا" است.

برای مثال، یک رویداد `focus` بالا نمی‌روند. مثال‌های دیگری نیز وجود دارد که با آنها آشنا خواهیم شد. با این حال این یک استثنا است تا یک قانون. بیشتر رویدادها بالا می‌روند.
```

## event.target

یک کنترل‌کننده روی یک عنصر والد همیشه می‌تواند جزئیاتی درباره اینکه رویداد درواقعیت کجا اتفاق افتاده است را بگیرد.

**عمیق‌ترین عنصری که باعث فراخوانی یک رویداد شده را عنصر *هدف* می‌نامند، که می‌توانیم با `event.target` به آن دسترسی یابیم.**

به تفاوت آن با `this` دقت کنید (=`event.currentTarget`):

- `event.target` -- عنصر "هدف" است که رویداد را برای اولین بار فراخوانی کرده، در طول روند بالارفتن تغییر نمی‌کند.
- ‍`this` -- عنصر "فعلی" است، که رویداد در حال حاضر روی آن در حال اجرا است.

برای مثال، اگر فقط یک کنترل‌کننده روی `form.onclick` داشته باشیم، سپس می‌تواند همه کلیک‌های داخل فرم را "بگیرد". بدون توجه به اینکه کلیک کجا اتفاق افتاده، همه راه را تا `<form>` بالا می‌رود و کنترل‌کننده را اجرا می‌کند.

درون کنترل‌کننده `form.onclick`:

- `this` (=`event.currentTarget`) همان عنصر `<form>`‌ است، چون کنترل‌کننده روی آن اجرا شده.
‍‍- `event.target` عنصری درون فرم که در اصل کلیک روی آن اتفاق افتاده.

ببینید:

[codetabs height=220 src="bubble-target"]

امکان دارد که `event.target` همان `this` باشد -- زمانی این اتفاق می‌افتد که دقیقا روی خود `<form>` کلیک شود.

## جلوگیری از بالارفتن

یک ایونت بالارونده از عنصر هدف مستقیما به بالا حرکت می‌کند. معمولا تا `<html>` بالا می‌رود، سپس به شئ `document` می‌رسد. بعضی از رویدادها حتی به `window` هم می‌رسند، و همه کنترل‌کننده‌ها را در راه خودش صدا می‌زوند.

اما هر کنترل‌کننده‌ می‌تواند تصمیم بگیرد که رویداد کاملا پردازش شده و بالارفتن را متوقف کند.

متدی که برای این‌ کار استفاده می‌شود ‍`event.stopPropagation()` است.

برای مثال، اینجا `body.onclick` در صورتی که روی `<button>` کلیک شود عمل نمی‌کند:

```html run autorun height=60
<body onclick="alert(`رویداد به اینجا نمی‌رسد`)">
  <button onclick="event.stopPropagation()">کلیک کنید</button>
</body>
```

```smart header="event.stopImmediatePropagation()"
اگر که یک عنصر چند کنترل‌کننده برای یک رویداد داشته باشد، در صورتی که حتی یکی از آنها از بالارفتن رویداد جلوگیری کند، بقیه باز هم اجرا می‌شوند.

به عبارت دیگر، `event.stopPropagation()` حرکت رو به بالا را متوقف می‌کند، اما روی همین عنصر فعلی، بقیه کنترل‌کننده‌ها اجرا می‌شوند.

برای توقف بالارفتن و جلوگیری از اجرای بقیه کنترل‌کننده‌ها عنصر فعلی، یک متد به نام `event.stopImmediatePropagation()` وجود دارد. بعد از آن هیچ کنترل‌کننده دیگری اجرا نمی‌شود.
```

```warn header="اگر نیاز نیست، بالارفتن رویداد را متوقف نکنید‍‍‍!"
رفتار بالارفتن ساده است. بدون یک نیاز واقعی آنرا متوقف نکنید: بدیهی و از نظر معماری خوب تدبیر شده باشد.

بعضی اوقات `event.stopPropagation()` یک مشکلی ایجاد می‌کند که ممکن است بعدا باعث وقوع دردسرهایی شود.

برای مثال:

1. ما یک منوی تو در تو ایجاد می‌کنیم. هر زیرمنو کلیک‌ها را روی عناصر کنترل می‌کند و `stopPropagation` را صدا می‌زند پس منوی بیرونی فعال نمی‌شود.
2. بعدا تصمیم می‌گیریم برای پی‌گیری رفتار کاربر (جایی که کاربر کلیک می‌کند) کلیک‌ها را روی کل پنجره دریافت کنیم. بعضی از سیستم‌های تحلیل این کار را انجام می‌دهند. معمولا کد از `document.addEventListener('click'…)` برای گرفتن همه کلیک ها استفاده می‌کند.
3. سیستم تحلیل ما جایی که کلیک‌ها توسط `stopPropagation` متوقف می‌شوند کار نمی‌کند. متاسفانه ما یک "محدوده مرده" داریم.

معمولا نیاز واقعی به جلوگیری از رفتار بالارفتن رویدادها نیست. کاری که ظاهرا نیاز به آن دارد، ممکن است با روش‌های دیگر قابل حل باشد. یکی از آنها استفاده از رویدادهای دستی است که بعدا به آنها می‌پردازیم. همچنین می‌توانیم در یک کنترل‌کننده اطلاعاتی را داخل شئ `event` بنویسیم و در کنترل‌کننده دیگری آن اطلاعات را بخوانیم. سپس آنرا به به کنترل‌کننده‌هایی که روی عناصر والد هستند بفرستیم. با اینکار.
```


## گرفتن

یک فاز دیگر در پردازش رویدادها وجود دارد به نام "گرفتن" یا "capturing". به ندرت در کد واقعی استفاده می‌شود، اما گاهی اوقات کارآمد است.

[رویداد‌های DOM](http://www.w3.org/TR/DOM-Level-3-Events/) استاندارد سه فاز از انتشار رویداد معرفی می‌کنند:

1. فاز گرفتن -- رویداد پایین می‌رود تا به عنصر برسد.
2. فاز هدف -- رویداد به عنصر هدف می‌رسد.
3. فاز بالارفتن -- رویداد از عنصر بالا می‌رود.

این یک عکس از یک کلیک روی `<td>` داخل یک جدول است، که شامل مشخصات زیر است

![](eventflow.svg)

اینگونه که: برای یک کلیک روی `<td>` رویداد اول از زنجیره اجداد پایین می‌آید تا به عنصر برسد‌(گرفتن). بعد به عنصر هدف می‌رسد و بعد بالا می‌رود (بالارفتن) و کنترل‌کننده‌ها را در مسیر صدا می‌زند.

**قبلا تنها درباره بالارفتن رویداد صحبت کردیم، چون که فاز گرفتن به ندرت استفاده می‌شود. معمولا برای ما نمایان نیست.**

کنترل‌کننده‌هایی که با استفاده از خاصیت `on<event>` یا صفت‌های HTML یا با متد با دو ورودی `addEventListener(event, handler)` اضافه می‌شوند، چیزی درباره گرفتن نمی‌دانند. فقط در فازهای دوم و سوم اجرا می‌شوند.

برای گرفتن یک رویداد در فاز گرفتن، باید که ورودی سوم `addEventListener` را `true` قرار دهیم.

برای آخرین ورودی که اختیاری دو مقدار می‌تواند وجود داشته باشد:

- اگر `false` باشد (پیش‌فرض)، کنترل‌کننده در فاز بالارفتن مشخص می‌شود.
- اگر `true` باشد، کنترل‌کننده در فاز گرفتن مشخص می‌شود.

توجه کنید که هنگامی رسما سه فاز وجود دارد، فاز دوم ("فاز هدف": رویداد به عنصر هدف رسیده است) به صورت جداگانه کنترل نمی‌شود: کنترل‌کننده‌های هر دو فاز گرفتن و بالا رفتن در این فاز فراخوانی می‌شوند.

اگر روی یک عنصر هدف کنترل‌کننده‌های گرفتن و بالارفتن تنظیم شود، کنترل‌کننده گرفتن، آخرین اجرا در فاز گرفتن اجرا می‌شود و کنترل‌کننده بالارفتن، اولین اجرا در فاز بالارفتن اجرا می‌شود.

بیایید تا در عمل ببینیم:

```html run autorun height=140 edit
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`گرفتن: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`بالارفتن: ${elem.tagName}`));
  }
</script>
```

این کد روی *هر* عنصر یک کنترل‌کننده کلیک تنظیم می‌کند تا ببینیم کدام یک کار می‌کنند.

اگر روی `<p>` کلیک کنیم، بعد ترتیب به این صورت است:

1. `HTML` -> `BODY` -> `FORM` -> `DIV` (فاز گرفتن, اولین شنونده):
2. `P` (فاز هدف, دوباره فراخوانی می‌شود, به این دلیل که ما دو شنونده روی آن تنظیم کردیم: گرفتن و بالارفتن)
3. `DIV` -> `FORM` -> `BODY` -> `HTML` (فاز بالارفتن, شنونده دوم).

توجه کنید که `P` دوبار نمایش داده می‌شود: در پایان گرفتن و در زمان شروع بالارفتن.

خاصیت `event.eventPhase` به ما شماره فازی که در آن رویداد فراخوانی شده را می‌گوید. اما به ندرت استفاده می‌شود چون معمولا در کنترل‌کننده آنرا می‌دانیم.

## خلاصه

روند کنترل رویداد:

- پس رویداد از ریشه که شئ document است به پایین حرکت می‌کند تا به `event.target` برسد، در حین حرکت کنترل‌کننده‌هایی که با `addEventListener(..., true)` تنظیم شده‌اند را صدا می‌زند (`true` مخفف ‍`{capture: true}`).
- سپس کنترل‌کننده‌های روی خود هدف صدا زده می‌شوند.
- سپس رویداد بالا می‌رود و از `event.target` به ریشه می‌رود، کنترل‌کننده‌هایی که با استفاده از `on<event>`، صفت‌های HTML و ‍`addEventListener` بدون ورودی سوم یا با ورودی سوم به صورت `false/{capture:false}` در مسیر خود فرا می‌خواند.

هر کنترل‌کننده به خصوصیات یک شئ `event` دسترسی دارد:

- `event.target` -- عمیق‌ترین عنصری که رویداد را ایجاد کرده.
- `event.currentTarget` (=`this`) -- عنصر فعلی که رویداد را کنترل می‌کند (عنصری که کنترل‌کننده روی آن است)
- `event.eventPhase` -- فاز کنونی‌ (گرفتن=1، بالارفتن=3)

هر کنترل‌کننده‌ای می‌تواند رویداد را با `event.stopPropagation()` متوقف کند، اما این روش پیشنهاد نمی‌شود چون که همیشه مطمئن نیستیم که رویداد را در مرحله‌های بالاتر نیاز نخواهیم داشت، شاید برای کارهایی کاملا متفاوت.

فاز گرفتن به ندرت استفاده می‌شود، معمولا رویدادها را در فاز بالارفتن کنترل می‌کنیم. و یک منطق پشت آن است.

در دنیای واقعی، زمانی که تصادفی رخ‌ میدهد، مقامات محلی زودتر عکس العمل نشان می‌دهند. آنها بهتر از هر کس دیگری درباره محلی که این حادثه رخ داده اطلاعات دارند. بعد از آنها در صورت نیاز مقامات بالاتر.

برای کنترل‌کننده‌های رویدادها نیز به همین شکل است. کدی که یک کنترل‌کننده برای یک عنصر به خصوص اختصاص می‌دهد، بیشترین جزئیات را درباره آن عنصر و کاری که انجام می‌دهد می‌داند. کنترل‌کننده روی یک `<td>` به خصوص ممکن است فقط برای دقیقا همان `<td>`  مناسب باشد، همه چیز را درباره آن می‌داند. پس اولین موقعیت را باید داشته باشد. بعد اولین والد او همچنین درباره مفاهیم اطلاعات دارد، اما مقداری کمتر و همینطور تا بالاترین عنصری که مفاهیم کلی را می‌داند و آخرین کنترل‌کننده را اجرا می‌کند.

بالارفتن و گرفتن پایه‌گذاری برای "واگذاری رویداد" هستند. -- یک الگوی بسیار قدرتمند برای کنترل رویداد‌ها که در بخش‌های بعدی آموزش خواهیم دید.
