# الگو ها و پرچم ها (Patterns and flags)

عبارات باقاعده(Regular expressions) الگوهایی هستند که روشی قدرتمند برای جستجو و جایگزینی در متن ارائه می دهند.

در جاوا اسکریپت، آنها از طریق شیء [RegExp](mdn:js/RegExp) و همچنین به خوبی با متد های رشته ها ادغام می شوند.

## عبارات باقاعده (Regular Expressions)

عبارت باقاعده (همچنین "regexp"، یا فقط "reg") از یک *الگو(pattern)* و *پرچم(flags)* های اختیاری تشکیل شده است.

دو سینتکس وجود دارد که می توان از آنها برای ایجاد یک شیء عبارت باقاعده استفاده کرد.

سینتکس "طولانی":

```js
regexp = new RegExp("pattern(الگو)", "flags(پرچم)");
```

و سینتکس "کوتاه" نیز، استفاده از اسلش `"/"` می باشد.

```js
regexp = /pattern/; // بدون پرچم
regexp = /pattern/gmi; // با پرچم g, m, i (به زودی پوشش داده میشود)
```

اسلش های `pattern:/.../` به جاوا اسکریپت می گوید که ما در حال ایجاد یک عبارت باقاعده هستیم. آنها همان نقش کوتیشن('') را برای رشته ها بازی می کنند.

در هر دو مورد، `regexp` به یک نمونه از کلاس داخلی `RegExp` تبدیل می‌شود.

تفاوت اصلی بین این دو سینتکس در این است که الگو با استفاده از اسلش‌های `/.../`، اجازه درج عبارات را نمی دهد (مانند حروف الفبای قالب(template literals) رشته با `${...}`). آنها کاملا ساکن هستند.

اسلش ها زمانی استفاده می شوند که عبارت باقاعده را در زمان نوشتن کد بدانیم -- و این رایج ترین حالت است. در حالی که `new RegExp` بیشتر زمانی استفاده می شود که ما نیاز به ایجاد یک regexp "در حال پرواز" از یک رشته تولید شده به صورت پویا داشته باشیم. برای مثال:

```js
let tag = prompt("چه بر چسبی می خواهید پیدا کنید؟", "h2");

let regexp = new RegExp(`<${tag}>`); // مانند /<h2>/ اگر در اعلان بالا "h2" پاسخ داده شود
```

## پرچم ها (Flags)

عبارات باقاعده ممکن است دارای پرچم هایی باشند که بر جستجو تأثیر می گذارد.

در جاوا اسکریپت، فقط 6 مورد از آنها وجود دارد:

`pattern:i`
: با این پرچم، جستجو به حروف کوچک و بزرگ حساس نیست: تفاوتی بین `A` و `a` نمی گذارد (به مثال زیر مراجعه کنید).

`pattern:g`
: با این پرچم، جستجو برای همه موارد منطبق، بدون آن - فقط اولین موردی که هم خوانی دارد، برگردانده می شود.

`pattern:m`
: حالت چند خطی (در فصل <info:regexp-multiline-mode> پوشش داده شده است).

`pattern:s`
: حالت `dotall` را فعال می‌کند، که به یک نقطه `.:pattern` اجازه می‌دهد تا با کاراکتر خط جدید `n\` مطابقت داشته باشد (در فصل <info:regexp-character-classes> پوشش داده شده است).

`pattern:u`
: پشتیبانی کامل از یونیکد را فعال می کند. پرچم پردازش صحیح جفت های جایگزین را امکان پذیر می کند. اطلاعات بیشتر در مورد آن در فصل <info:regexp-unicode>.

`pattern:y`
: حالت `Sticky`: جستجو در موقعیت دقیق متن (در فصل <info:regexp-sticky> پوشش داده شده است)

```smart header="Colors"
از اینجا به بعد رنگ بندی به این صورت است:

- regexp -- `pattern:red`
- string (where we search) -- `subject:blue`
- result -- `match:green`
```

## جستجو: str.match

همانطور که قبلا ذکر شد، عبارات باقاعده با متدهای رشته ای ادغام می شوند.

متد `str.match(regexp)` همه مطابقت‌ های `regexp` را در رشته `str` پیدا می‌کند.

و دارای 3 حالت کار است:

1. اگر عبارت باقاعده دارای پرچم `pattern:g` باشد، آرایه‌ای از همه موارد مطابق را بر می‌ گرداند:
    ```js run
    let str = "We will, we will rock you";

    alert( str.match(/we/gi) ); // We,we (آرایه ای از 2 رشته که مطابقت دارند)
    ```
    لطفاً توجه کنید که `match:We` و `match:we` نتیجه یکسانی میدهند، زیرا پرچم `pattern:i` باعث می‌شود که عبارت باقاعده به حروف بزرگ و کوچک حساس نباشد.

2. اگر چنین پرچمی وجود نداشته باشد، فقط اولین تطابق را در یک آرایه، با تطابق کامل در ایندکس `0` و برخی جزئیات اضافی در ویژگی ها بر می گرداند:
    ```js run
    let str = "We will, we will rock you";

    let result = str.match(/we/i); // without flag g

    alert( result[0] );     // We (1st match)
    alert( result.length ); // 1

    // Details:
    alert( result.index );  // 0 (موقعیت تطابق)
    alert( result.input );  // We will, we will rock you (رشته منبع)
    ```
    
    اگر بخشی از عبارت باقاعده در داخل پرانتز قرار بگیرد، ممکن است آرایه، ایندکس های دیگری در کنار ایندکس `0` نیز داشته باشد. ما آن را در فصل <info:regexp-groups> پوشش خواهیم داد.

3. و در نهایت، اگر هیچ تطابقی وجود نداشته باشد، `null` بر می گرداند. (فرقی نمی‌کند که پرچم `pattern:g` وجود داشته باشد یا خیر).

    این یک فرق ریز و بسیار مهم است. اگر هیچ تطابقی وجود نداشته باشد، یک آرایه خالی دریافت نمی‌کنیم، بلکه `null` دریافت می‌ کنیم. فراموش کردن آن ممکن است منجر به خطاهایی شود، به عنوان مثال:

    ```js run
    let matches = "JavaScript".match(/HTML/); // = null

    if (!matches.length) { // Error: Cannot read property 'length' of null
      alert("Error in the line above");
    }
    ```

    اگر می‌خواهیم نتیجه همواره یک آرایه باشد، می‌ توانیم آن را به این صورت بنویسیم:

    ```js run
    let matches = "JavaScript".match(/HTML/)*!* || []*/!*;

    if (!matches.length) {
      alert("No matches"); // now it works
    }
    ```

## جایگزین کردن: str.replace

روش `str.replace(regexp، replacement)` تطابق ‌هایی را که با استفاده از `regexp` در رشته `str` یافت می‌شود را با `replacement` جایگزین می‌کند (همه منطبق هستند اگر پرچم `pattern:g` وجود داشته باشد، در غیر این صورت، فقط اولین مورد است).

برای مثال:

```js run
// no flag g
alert( "We will, we will".replace(/we/i, "I") ); // I will, we will

// with flag g
alert( "We will, we will".replace(/we/ig, "I") ); // I will, I will
```

آرگومان دوم رشته، `replacement(جایگزینی)` است. می‌توانیم از ترکیب کاراکتر های ویژه در آن برای درج قطعاتی از تطابق استفاده کنیم:

| نماد | عمل در رشته جایگزین |
|--------|--------|
|`$&`|کل تطابق را درج می کند|
|<code>$&#096;</code>|قسمتی از رشته را قبل از تطابق وارد می کند|
|`$'`|قسمتی از رشته را بعد از تطابق وارد می کند|
|`$n`|اگر`n` یک عدد 1-2 رقمی باشد، محتویات پرانتزهای n را درج می کند، اطلاعات بیشتر در مورد آن در فصل <info:regexp-groups>|
|`$<name>`|محتویات پرانتز را با `name` داده شده درج می کند، اطلاعات بیشتر در مورد آن در فصل <info:regexp-groups>|
|`$$`|کاراکتر "$" را درج می کند |

مثالی برای `pattern:$&`:

```js run
alert( "I love HTML".replace(/HTML/, "$& and JavaScript") ); // I love HTML and JavaScript
```

## تست کردن: regexp.test

متد `regexp.test(str)` حداقل یک تطابق را جستجو می‌کند، در صورت یافتن `true`، در غیر این صورت `false` بر میگرداند.

```js run
let str = "I love JavaScript";
let regexp = /LOVE/i;

alert( regexp.test(str) ); // true
```

بعداً در این فصل، عبارات باقاعده بیشتری را یاد می گیریم. مثال‌های بیشتری را مرور می‌ کنیم، و همچنین با روش‌ های دیگر آشنا می‌ شویم.

اطلاعات کامل در مورد متد ها در مقاله <info:regexp-methods> آورده شده است.

## خلاصه

- یک عبارت باقاعده از یک الگو و پرچم‌های اختیاری تشکیل شده است: `pattern:g`، `pattern:i`، `pattern:m`، `pattern:u`، `pattern:s`، `pattern:y`.
- بدون پرچم و نمادهای خاص (که بعداً مطالعه خواهیم کرد)، جستجو توسط regexp مانند جستجوی زیر رشته(substring) است.
- متد `str.match(regexp)` به دنبال تطابق است: اگر پرچم `pattern:g` وجود داشته باشد، همه آنها را بر میگرداند، در غیر این صورت، فقط اولین مورد را بر میگرداند.
- متد `str.replace(regexp، replacement)»` تطابق های یافت شده با استفاده از `regexp` را با `replacement` جایگزین می‌کند: به همه آنها این فرایند را اعمال میکند اگر پرچم `pattern:g` وجود داشته باشد، در غیر این صورت فقط به اولین مورد اعمال میکند.
- متد `regexp.test(str)` اگر حداقل یک مورد مطابقت داشته باشد، `true` بر می‌گرداند، در غیر این صورت، `false` بر می‌گرداند.
