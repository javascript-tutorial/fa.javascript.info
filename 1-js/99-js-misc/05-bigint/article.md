# BigInt

[recent caniuse="bigint"]

`BigInt` یک نوع داده عددی خاص است که پشتیبانی برای تعریف اعداد صحیح با طول دلخواه را فراهم می کند.

یک bigint را می توان با اضافه کردن حرف `n` به انتهای یک عدد صحیح و یا با فراخوانی تابع `BigInt` که bigint ها را از اعداد، رشته ها و غیره بوجود می آورد، ساخت.

```js
const bigint = 1234567890123456789012345678901234567890n;

const sameBigint = BigInt("1234567890123456789012345678901234567890");

const bigintFromNumber = BigInt(10); // با 10n یکسان است
```

## عملگرهای ریاضی

یک `BigInt` را می توان عمدتا به صورت یک عدد عادی استفاده کرد، برای مثال:

```js run
alert(1n + 2n); // 3

alert(5n / 2n); // 2
```

در نظر داشته باشید: عملیات تقسیم `5/2` نتیجه را بدون قسمت اعشار و رند شده به سمت صفر، باز می گرداند. همه ی عملیات بر روی bigint ها، مقداری را از نوع bigint باز می گردانند.

اعداد نوع bigint را نمی توان با اعداد معمولی مخلوط کرد:

```js run
alert(1n + 2); // Error: Cannot mix BigInt and other types
```

در صورت نیاز می بایست آن ها را به صورت زیر، توسط `BigInt()` یا `Number()` تبدیل کرد:

```js run
let bigint = 1n;
let number = 2;

// تبدیل نوع number به bigint
alert(bigint + BigInt(number)); // 3

// تبدیل نوع bigint به number
alert(Number(bigint) + number); // 3
```

عملیات تبدیل به صورت ساکت عمل می کنند، و خطایی باز نمی گردانند، اما اگر مقدار bigint بسیار بزرگ باشد و در نوع عدد (number) نگنجد، ارقام اضافی آن از بین خواهد رفت، پس در این نوع تبدیل همیشه مراقب باشید.

````smart header="جمع یکانی بر روی bigint ها پشتیبانی نمی شود"
عملگر جمع یکانی `+value` راهی شناخته شده برای تبدیل یک `value` به نوع داده عددی (number) است.

برای جلوگیری از درهم شدن، این عملگر روی bigint ها پشتیبانی نمی شود.
```js run
let bigint = 1n;

alert( +bigint ); // خطا
```
پس باید از `Number()` برای تبدیل یک bigint به نوع عددی استفاده کنیم.
````

## عملگرهای مقایسه ای

عملگرهای مقایسه نظیر `<` و `>` بدون مشکل بر روی bigint ها و اعداد (number) کار می کنند:

```js run
alert( 2n > 1n ); // true

alert( 2n > 1 ); // true
```

البته در نظر داشته باشید که با توجه به متفاوت بودن نوع داده ای bigint و number، با عملگر `==` می توان آن ها را مقایسه کرد، اما با عملگر `===` خیر.

```js run
alert( 1 == 1n ); // true

alert( 1 === 1n ); // false
```

## عملیات منطقی

داخل ساختارهای شرطی `if` یا سایر عملیات منطقی، bigint ها همچون اعداد معمولی رفتار می کنند.

برای مثال، مقدار bigint برابر با `0n`، در ساختارهای شرطی، ناصحیح (false) است و سایر مقادیر، صحیح (true) هستند.

```js run
if (0n) {
  // هیچ وقت اجرا نمی شود.
}
```

عملگرهای منطقی نظیر `||` و `&&` روی bigint ها، مشابه نوع عددی (number) عمل می کنند:

```js run
alert( 1n || 2 ); // 1 (1n، true در نظر گرفته می شود)

alert( 0n || 2 ); // 2 (0n، false در نظر گرفته می شود)
```

## پالیفیل ها

پالیفیل کردن bigint ها مقداری متفاوت است، به این علت که بسیاری از عملگرهای جاوا اسکریپت، مثل `+`، `-` و بسیاری دیگر، واکنش های مختلفی را را با bigint ها نسبت به اعداد معمولی دارند.

برای مثال، تقسیم bigint ها، همیشه یک مقدار bigint باز می گرداند، که در صورت لزوم، گرد می شود.

برای تقلید چنین رفتاری، یک پالیفیل باید کد را بررسی کرده، و تمامی عملگرهای این چنین را با توابعش جایگزین کند. اما انجام چنین کاری سنگین است و به مقدار زیادی کارایی را کاهش می دهد.

به همین خاطر، پالیفیل شناخته شده خوبی برای این کار وجود ندارد.

با این حال، روش دیگری توسط توسعه دهندگان کتابخانه [JSBI](https://github.com/GoogleChromeLabs/jsbi) پیشنهاد شده است.

این کتابخانه، اعداد بزرگ را به روش های خود پیاده سازی می کند. می توانیم از آنها به جای bigint های بومی جاوا اسکریپت استفاده کنیم: 

| عملیات | بومی `BigInt` | JSBI |
|-----------|-----------------|------|
| ساختن از روی عدد | `a = BigInt(789)` | `a = JSBI.BigInt(789)` |
| افزودن | `c = a + b` | `c = JSBI.add(a, b)` |
| تفریق	| `c = a - b` | `c = JSBI.subtract(a, b)` |
| ... | ... | ... |

و سپس می توان از پالیفیل (پلاگین Babel) برای تبدیل فراخوانی های JSBI به bigint های بومی استفاده کرد تا مرورگرها از آن پشتیبانی کنند.

به بیانی دیگر، این رویکرد پیشنهاد می کند که به جای استفاده از bigint های بومی جاوا اسکریپت، کدهای مربوطه را در JSBI بنویسیم. اما JSBI با اعداد، همانند bigint ها به صورت داخلی کار می کند، و مطابق مشخصات تعیین شده، آن ها را به گونه ای تقلید می کند که کد، آماده استفاده bigint (bigint-ready) باشد.

ما می توانیم کد JSBI را همان گونه که هست، چه برای موتور(engine) هایی که bigint ها را پشتیبانی می کنند، و چه برای آن هایی که پشتیبانی نمی کنند، استفاده کنیم. پالیفیل، فراخوانی های مربوطه را به bigint های بومی تبدیل می کند.

## منابع

- [مستندات MDN درباره BigInt](mdn:/JavaScript/Reference/Global_Objects/BigInt).
- [Specification](https://tc39.es/ecma262/#sec-bigint-objects).
