
1. برای اینکه همه چیز به *هر نحوی* کار کند، نتیجه `sum` باید تابع باشد.
2. آن تابع باید بین فراخوانی‌ها مقدار کنونی را در حافظه ذخیره کند.
3. با توجه به تمرین، تابع باید زمانی که با `==` استفاده می‌شود، تبدیل به عدد شود. تابع‌ها شیء هستند پس تبدیل شدن همانطور که در فصل <info:object-toprimitive> گفته شد اتفاق می‌افتد و ما می‌توانیم متد خودمان را برای برگرداندن عدد بسازیم.

حالا می‌رسیم به کد:

```js demo run
function sum(a) {

  let currentSum = a;

  function f(b) {
    currentSum += b;
    return f;
  }

  f.toString = function() {
    return currentSum;
  };

  return f;
}

alert( sum(1)(2) ); // 3
alert( sum(5)(-1)(2) ); // 6
alert( sum(6)(-1)(-2)(-3) ); // 0
alert( sum(0)(1)(2)(3)(4)(5) ); // 15
```

لطفا در نظر داشته باشید که تابع `sum` فقط یکبار کار می‌کند. تابع `f` را برمی‌گرداند.

سپس در هر فراخوانی زیر مجموعه آن، تابع `f` پارامتر خودش را به جمع `currentSum` اضافه می‌کند و خودش را برمی‌گرداند.

**هیچ بازگشتی در آخرین خط `f` وجود ندارد.**

بازگشتی اینگونه بنظر می‌رسد:

```js
function f(b) {
  currentSum += b;
  return f(); // <-- فراخوانی بازگشتی
}
```

و در این مورد ما، بدون صدا زدن تابع، ما فقط آن را برمی‌گردانیم:

```js
function f(b) {
  currentSum += b;
  return f; // <-- خودش را صدا نمی‌زد، خودش را برمی‌گرداند
}
```

این `f` در فراخوانی بعدی استفاده می‌شود و دوباره خودش را برمی‌گرداند، هر چند باری که نیاز باشد. سپس زمانی که به عنوان یک عدد یا رشته استفاده می‌شود -- `toString` مقدار `currentSum` را برمی‌گرداند. ما می‌توانستیم برای تبدیل از `Symbol.toPrimitive` یا `valueOf` اینجا استفاده کنیم.
