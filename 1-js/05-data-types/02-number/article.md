# اعداد

تمامی اعداد در جاوااسکریپت به فرمت ۶۴-بیتی ذخیره می‌شوند. [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754-1985)، همینطور شناخته شده با نام "دقت دوبرابر"

بگذارید ابتدا تمام چیزهایی که راجبشان را میدانیم را باز و جمع‌بندی کنیم.
## راه‌های دیگر نوشتن یک عدد


فرض کنید نیاز داریم بنویسیم یک میلیارد. راه واضح این است که: 

```js
let billion = 1000000000;
```

<<<<<<< HEAD
اما در زندگی واقعی ما عموما از نوشتن رشته حرف با تعداد زیاد صفر خودداری میکنیم به خاطر اینکه به راحتی ممکن است خطا داشته باشیم و اشتباه بنویسیم. همینطور، ما تنبل هستیم! ما معمولا یه چیزی شبیه `"1bn"` مینویسیم به جای یک میلیارد یا  `"7.3bn"` برای هفت میلیارد و سیصد میلیون. این حقیقت برای اکثر اعداد بزرگ هم صحیح است.
=======
But in real life, we usually avoid writing a long string of zeroes as it's easy to mistype. Also, we are lazy. We will usually write something like `"1bn"` for a billion or `"7.3bn"` for 7 billion 300 million. The same is true for most large numbers.

In JavaScript, we shorten a number by appending the letter `"e"` to the number and specifying the zeroes count:
>>>>>>> be342e50e3a3140014b508437afd940cd0439ab7

در جاوااسکریپت، ما یک عدد را براساس اضافه کردن حرف `"e"` به انتهای آن خلاصه میکنیم و با آن تعداد صفرها مشخص میشود.
```js run
let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes

alert( 7.3e9 );  // 7.3 billions (7,300,000,000)
```

به زبانی دیگر، `"e"` عدد را در ۱ با تعداد صفر داده شده ضرب می‌کند.
```js
1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000 
```


حالا بگذارید مقداری خیلی کوچک بنویسیم. مثلا؛ یک میکروثانیه، (یک میلیونیوم ثانیه):

```js
let ms = 0.000001;
```

دقیقا مثل قبل، استفاده از `"e"` میتواند کمک کند. اگر ما بخواهیم که از نوشتن صفرها خودداری کنیم، میتوانیم بنویسیم که:

```js
let ms = 1e-6; // شش صفر در چپ ۱ 
```

اگر ما تعداد صفرهای `0.000001` را بشماریم، شش تا از آنها موجودست. بنابراین طبعا می‌شود `1e-6`.

به زبانی دیگر، یک عدد منفی بعد `"e"`، به معنی  تقسیم بر یک با تعداد صفرهای داده شده است.

```js
// -3 divides by 1 with 3 zeroes
1e-3 = 1 / 1000 (=0.001)

// -6 divides by 1 with 6 zeroes
1.23e-6 = 1.23 / 1000000 (=0.00000123)
```

### اعداد پایه ۱۶، دودویی، پایه ۸

 
[اعداد پایه ۱۶](https://en.wikipedia.org/wiki/Hexadecimal) برای نمایش رنگ‌ها، کدگذاری حروف و بسیاری دیگر، به طور وسیعی در جاوااسکریپت مورد استفاده قرار می‌گیرند. بنابراین، یک راه کوتاهتری برای نوشت آنها وجود دارد: `0x` و سپس عدد.

به عنوان مثال:

```js run
alert( 0xff ); // 255
alert( 0xFF ); // 255 (the same, case doesn't matter)
```

اعداد هشت‌تایی و دودویی به ندرت مورد استفاده قرار میگیرند اما نحوه‌ی استفاده‌ی آنها به صورت پیشوند‌های `0b` و `0o` است:

```js run
let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255

alert( a == b ); // true, the same number 255 at both sides
```

سه نوع سیستم عددی با پشتیبانی مخصوص به خود وجود دارد. برای بقیه‌ی سیستم‌ها ما باید از تابع  `parseInt` استفاده کنیم. (که ما در بخش‌های بعدی خواهیم دید.)
## toString(base)

تابع  `num.toString(base)`، یک رشته حرف نمایشگر `num` را در سیستم عددی با پایه داده شده خروجی می‌دهد.

به عنوان مثال:

```js run
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

پایه میتواند از بین `۲` تا `۳۶` تغییر کند. در حالت عادی، `۱۰` است.

حالات معمول استفاده بدین شکلند:

**base=16** برای رنگ‌های هگزایی، کدگذاری حروف و غیره، ارقام میتوانند به صورت `0..9` یا `A..F` باشند.

**base=2** برای دیباگ کردن عملوند‌های بیتی هستند، ارقام میتوانند `0` یا `1` باشند. 

**base=36** بزرگترین است، ارقام میتوانند `0..9` یا `A..Z` باشند. کل الفبای لاتین برای نمایش یک عدد مورد استفاده قرار میگیرد. یک حالت خنده دار، اما مفید برای  `۳۶` وقتی است که ما نیاز داریم تا یک نشانگر بزرگ عددی را به چیز کوچکتری تبدیل کنیم، به عنوان مثال برای . ساختن لینک‌ های کوتاه شده (short url). میتوان به سادگی اعداد را در پایه‌ی `۳۶` نمایش داد:
```js run
alert( 123456..toString(36) ); // 2n9c
```

```warn header="دو نقطه برای صدا زدن یک تابع"

توجه داشته باشید که دو نقطه در `123456..toString(36)`، غلط املایی نیست. اگر میخواهیم یک تابعی را مستقیما روی عدد صدا بزنیم مثل `toString` در مثال بالا، آنگاه ما نیاز داریم تا بعد از آن دوتا نقطه بگذاریم.

اگر ما یک نقطه بگذاریم: `123456.toString(36)`، آنگاه خطایی به وجود می‌آید، چراکه قواعد نوشتاری جاوااسکریپت بعد از یک نقطه، آن را قسمت اعشاری آن در نظر میگیرد. و اگر یک نقطه بیشتر بگذاریم، جاوااسکریپت فرض میکند قسمت اعشاری خالی‌ست و سپس تابع فراخوانده میشود.

همچنین میتوانیم بنویسیم `(123456).toString(36)`:
```

## رند کردن


یکی از عملگرهایی در اعداد زیاد مورد استفاده قرار میگیرد، رند کردن است.

چندین تابع از پیش آماده شده برای رند کردن به شرح زیر است:
`Math.floor`
: رند پایین: `۳.۱` میشود `۳`, و `-۱.۱` میشود `-۲`.
`Math.ceil`
: رند بالا: `۳.۱` میشود `۴`, و `-۱.۱` میشود `-۱`.

`Math.round`
: رند کردن به نزدیک ترین عدد صحیح: `۳.۱` میشود `۳`, `۳.۶` میشود `۴` و `-۱.۱` میشود `-۱`.

`Math.trunc` (توسط اینترنت اکسپلورر ساپورت نمیشود)
: حذف کردن قسمت اعشاری بدون رند کردن: `۳.۱` میشود `۳`, `-۱.۱` میشود `-۱`.


این جدول تفاوت بین ‌آنهارا خلاصه کرده است:
|   | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
|---|---------|--------|---------|---------|
|`۳.۱`|  `۳`    |   `۴`  |    `۳`  |   `۳`   |
|`۳.۶`|  `۳`    |   `۴`  |    `۴`  |   `۳`   |
|`-۱.۱`|  `-۲`    |   `-۱`  |    `-۱`  |   `-۱`   |
|`-۱.۶`|  `-۲`    |   `-۱`  |    `-۲`  |   `-۱`   |


این توابع تمام حالات کار با قسمت اعشاری یک عدد را پوشش میدهند. اما چطور میتوانیم عدد را تا رقم `n-ام` بعد از اعشار رند کنیم؟

برای مثلا، داریم `۱.۲۳۴۵` و میخواهیم تا ۲ رقم اعشار آن را رند کنیم یعنی  `۱.۲۳`

دو روش برای اینکار داریم:

۱. ضرب و تقسیم

برای مثال، برای رند کردن عدد تا دومین رقم اعشاری، میتوانیم عدد را در ۱۰۰ ضرب کنیم، تابع رند کردن را صدا بزنیم و سپس دوباره تقسیم کنیم.
  
```js run
let num = 1.23456;

alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
```
۲. تابع [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) عدد را تا رقم `n-ام` بعد اعشار رند میکند و سپس آن را به صورت رشته حرفی حرفی خروجی میدهد.    
    
    
```js run
let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
```
این عدد را به نزدیک ترین مقدار رند میکند مشابه:
`Math.round`:

```js run
let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
```
توجه داشته باشید که مقدار `toFixed` یک رشته حرفی‌ست. اگر قسمت بعد اعشار کوچک‌ترین مقدار لازم است، صفر به آخر آن اضافه خواهد شد:
    
```js run
let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", صفر اضافه شده تا دقیقا ۵ رقم شود 
```

ما میتوانیم آن را با کمک جمع واحد یا با فراخوانی `Number()` در `+num.toFixed(5)` به عدد تبدیل کنیم

## محاسبات تقریبی

در درون سیستم، یک عدد به شکل ۶۴-بیتی است [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754-1985)، بنابراین دقیقا ۶۴ بیت برای ذخیره‌ی یک عدد داریم: ۵۲ تا از آنها برای ذخیره کردن ارقام هستند، ۱۱ تا از آنها برای ذخیره کردن جایگاه نقطه‌ی مشخص کننده‌ی اعشار (که برای اعداد صحیح صفر است)، و یک بیت برای علامت آن.

اگر عددی بیش از حد بزرگ باشد، حافظه‌ی ۶۴ بیتی سرریز میکند و مقدار بینهایت را برمیگرداند:
```js run
alert( 1e500 ); // Infinity 
```

اتفاقی که زیاد مشخص نیست و کمتر اتفاق می‌افتد، از دست دادن دقت است.

این آزمون (اشتباه!) را در نظر بگیرید:
```js run
alert( 0.1 + 0.2 == 0.3 ); // *!*false*/!*
```

این درست است، اگر ما بررسی کنیم که جمع `0.1` و `0.2`، `0.3` است، ما مقدار `false` را در جواب میگیریم.

عجیب است! چی هست پس اگر `0.3` نیست؟!
```js run
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

اوه! اتفاقات بدتری تا یک مقایسه‌ی ساده میتواند بیفتد. مثلا فرض کنید شما در فروشگاهی اینترنتی مقدار `$0.10` و `$0.20` را به حساب خود واریز میکنید. مجموع موجودی شما `$0.30000000000000004` میشود. این شکه کننده‌ست!

اما چرا این اتفاق می‌افتد؟

یک عدد در حافظه به شکل دودویی آن ذخیره میشود، مجموعه‌ای از صفرها و یک‌ها. اما کسرهایی مثل `0.1`، `0.2` که در سیستم اعداد اعشاری ساده به نظر میرسند در اصل کسرهای بی‌پایانی در شکل دودویی خود هستند.

به زبانی دیگر، `0.1` چیست؟ مقدار یک که بر ده تقسیم شده، `1/10` یعنی یک دهم. در سیستم اعداد اعشاری چنین اعدادی به سادگی قابل نمایشند. با یک سوم `1/3` مقایسه کنید. به کسری بی‌پایان تبدیل میشود. `0.33333(3)`

بنابراین، تقسیم های از توان ده، قطعا در سیستم اعشاری کار میکند اما تقسیم‌های بر ۳ اینطور نیست. به علت مشابه، در سیستم اعداد دودویی، تقسیم توان‌های ۲ هم قطعا کار میکند اما ۱/۱۰، کسر دودویی بی‌پایانی میشود.

در حقیقت هیچ راهی برای ذخیره کردن دقیقا ۰.۱ یا دقیقا ۰.۲ در سیستم دودویی وجود ندارد، دقیقا مثل اینکه برای ذخیره سازی مقدار یک سوم به عنوان یک کسر اعشاری راهی وجود ندارد.

فرمت عددی IEEE-754، این مسأله را با کمک رند کردن به نزدیک‌ترین عدد ممکن حل می‌کند. این قوانین رند کردن عموما نمیگذارند که ما آن مقدار کوچک دقت گم شده را متوجه بشویم، بنابراین عدد به شکل `0.3` خواهد بود. اما آگاه باشید که این از دست دادن دقت هنوز وجود دارد.

میتوانیم این را در عمل هم ببینیم:
```js run
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

و هنگامی که ما دو عدد را جمع میکنیم، مقدار از دست دادگی دقت آنها با هم جمع میشود.

به همین علت است که `0.1 + 0.2`، دقیقا `0.3` نمیشود.
```smart header="نه تنها جاوااسکریپت"

این مشکل در دیگر زبان‌های برنامه‌نویسی بسیاری وجود دارد.

PHP، Java، C، Perl، Ruby دقیقا نتیجه‌ی مشابه را میدهند چراکه بر پایه‌ی فرمت عددی یکسانی بنا شده‌‌اند.
```

آیا ما میتوانیم راهی برای حل این مسأله پیدا کنیم؟ طبعا، چندین راه وجود دارد:

۱. میتوانیم نتیجه ر با کمک یک تابع رند کنیم: [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed):

```js run
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

توجه داشته باشید که `toFixed` همیشه مقدار رشته حرفی برمیگرداند. این تابع حتما مطمئن میشود که تا دو رقم اعشار را حساب می‌کند. که البته این روش منطقی‌‌ست وقتی مثلا در یک فروشگاه اینترنتی ما نیاز داریم مقدار `$0.30` را نمایش دهیم. برای حالات دیگر، میتوانیم از جمع واحد استفاده کنیم تا آنرا به یک عدد تبدیل کنیم: 
```js run
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```


۲. ما میتوانیم موقتا اعداد را به مقادیر صحیح برای محاسبات ریاضی تبدیل کنیم و سپس آنرا به حالت قبل برگردانیم:
```js run
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
```

این راه عملی‌ست چراکه وقتی `0.1 * 10 = 1` و `0.2 * 10 = 2`، هر دو عددی صحیح میشوند، و دقتی از دست نمیرود.

۳. اگر ما داریم اینکار را برای یک فروشگاه انجام میدهیم، منطقی‌ترین راه این است که تمام قیمت‌ها را با مقدار سنت آن ذخیره کنیم و اصلا از هیچ مقدار کسری استفاده نکنیم. اما اگر ما بخواهیم یک تخفیف ۳۰ درصدی بدهیم چه اتفاقی می‌افتد؟  در عمل، حذف کردن تمامی کسرها تقریبا ممکن نیست، بنابراین راه‌حل های بالا ما را در حل این مسأله کمک می‌کنند. 
````smart header="یک چیز خنده‌دار!"

اجرا کنید:
```js run
// Hello! I'm a self-increasing number! 
alert( 9999999999999999 ); // shows 10000000000000000
```

این همان مشکل قبلی‌ست: از دست دادن دقت. برای عدد ۶۴ بیت وجود دارد، ۵۲ تا از آنها برای ذخیره‌ ارقام است اما این کافی نیست. پس کم اهمیت‌ترین ارقام ناپدید میشوند.

جاوااسکریپت در چنین جاهایی خطایی نمیفرستد گرچه نهایت سعیش را میکند تا عدد را در فرمت مربوطه قرار دهد اما این فرمت به اندازه کافی بزرگ نیست.
````

```smart header="دو صفر"

یک اتفاق جالب دیگر که در نمایش دادن اعداد درون سیستم می‌افتد وجود دو نوع صفر میباشد! `0` و `-0`.

این به این علت است که علامت با یک بیت مشخص میشود بنابراین هر عدد میتواند مثبت یا منفی باشد، حتی صفر.

در اکثر حالات، تفاوت غیرقابل توجه است، چراکه عملگرها برای داشتن رفتار یکسان وفق داده شده‌ند. 
```



## آزمون‌ها: isFinite و isNaN

آیا این دو مقدار عددی خاص را به یاد دارید؟

`Infinity` (و `-Infinity`) یک مقدار عددی خاص هستند بزرگتر (کوچکتر) از هرچیزی.

`NaN` یک خطا را نشان می‌دهد.

آنها به مدل `number` مربوطند اما اعداد معمولی نیستند، پس توابع خاصی برای بررسی آنها وجود دارد.


- `isNaN(value)` آرگومان‌هایش را به یک عدد تبدیل میکند و سپس آن را برای `NaN` بودن می‌آزماید:
```js run
    alert( isNaN(NaN) ); // true
    alert( isNaN("str") ); // true
```

اما آیا ما به این تابع نیاز داریم؟ نمیتوانیم صرفا از تساوی `=== NaN` استفاده کنیم؟‌ متاسفانه جواب خیر است. مقدار `NaN`، مقداری یکتاست و با هیچ چیز، حتی خودش برابر نیست.
```js run
alert( NaN === NaN ); // false
```

`isFinite(value)` آرگومان‌هایش را به عدد تبدیل میکند و در صورتی که عددی معمولی باشد `true` خروجی می‌دهد نه `NaN/Infinity/-Infinity`:

```js run
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, because a special value: NaN
alert( isFinite(Infinity) ); // false, because a special value: Infinity
```

بعضی اوقات `isFinite` برای صحت سنجی اینکه یک رشته حرفی، عددی معمولیست به کار برده می‌شود.

```js run
let num = +prompt("Enter a number", '');

// صحیح برگردانده میشود مگر اینکه وارد کنید Infinity, -Infinity یا چیزی غیر از عدد
alert( isFinite(num) );
```

توجه داشته باشید که رشته حرفی‌ای که در آن فقط یک جای خالی باشد یا کلا خالی باشد، به عنوان صفر در همه‌ی توابع عددی از جمله `isFinite` در نظر گرفته میشود.
```smart header="مقایسه کنید با `Object.is`"

یک تابع از پیش آماده شده‌ی خاص [Object.is](mdn:js/Object/is) که مقادیر را مثل `===` مقایسه میکند، اما برای دو حالت مرزی قابل اعتمادتر است.

۱. با `NaN` کار میکند:  `Object.is(NaN, NaN) === true`، که چیز خوبیست.

۲. مقادیر `0` و `-0` متفاوت هستند: `Object.is(0, -0) === false`، به ندرت اهمیت دارد، اما این مقادیر در اصل متفاوتند.

در تمام حالات دیگر، `Object.is(a, b)` با `a === b` برابراست.

این روش مقایسه عموما در جاوااسکریپت استفاده می‌شود. وقتی یک الگوریتم درون سیستمی به مقایسه کردن برای برابری دقیق دو مقدار  نیاز دارد، از `Object.is` استفاده می‌کند (که در درون سیستم به نام [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)) می‌باشد.)
```

## parseInt و parseFloat

تبدیلات عددی که از یک جمع `+` یا `Number()` استفاده میکنند، سخت‌گیر هستند.

```js run
alert( +"100px" ); // NaN
```


تنها استثنا، کاراکتر خالی در شروع یا انتهای رشته حرفی هستند که آنها در تابع در نظر گرفته نمی‌شوند.

اما در دنیای واقعی، ما مقادیر در واحدهای مختلفی داریم، مثل `"100px"` یا `"12pt"` در CSS. همینطور در بسیاری از کشورها، نماد پولی آنها بعد از مقدار عددی ظاهر میشود. مثل `"19€"`، که میخواهیم آن مقدار را از قسمت حرفی جدا کنیم.

به همین علت است که `parseInt` و `parseFloat` استفاده می‌شوند.

آنها یک عدد را از رشته‌ی حرف میخوانند تا زمانی که دیگر نتوانند. در صورت بروز خطا، عدد پیدا شده برگردانده می‌شود. تابع `parseInt` یک عدد صحیح برمیگرداند، در حالیکه `parseFloat` یک عدد اعشاری برمیگرداند.
```js run
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, تنها قسمت صحیح عدد برگردانده شده
alert( parseFloat('12.3.4') ); // 12.3, نقطه‌ی دومی، فرآیند خوانده شدن را متوقف می‌کند.
```

حالاتی وجود دارد که `parseInt/parseFloat` ممکن است مقدار `NaN` را برگردانند. این برای حالتی‌ست که هیچ رقمی نتواند خوانده شود:
```js run
alert( parseInt('a123') ); // NaN, اولین حرف این رشته‌ی حرفی، فرآیند را متوقف می‌کند.
```

````smart header="آرگومان دوم `parseInt(str, radix)`"

تابع `parseInt()`، یک پارامتر اختیاری دومی هم دارد که مقدار پایه‌ی سیستم عددی را مشخص میکند، به طبع میتوانیم رشته‌ حرفی اعداد پایه ۱۶، پایه ۲ و به همین ترتیب را به دست آوریم:
```js run
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, بدون 0x هم کار می‌کند

alert( parseInt('2n9c', 36) ); // 123456
```
````

## توابع ریاضی دیگر

جاوااسکریپت یک شئ از پیش آماده‌ شده [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) دارد که شامل کتابخانه‌ای کوچک از توابع ریاضی و ثوابت است.

تعدادی مثال:

`Math.random()`

: یک عدد تصادفی از بین ۰ تا ۱ برمی‌گرداند که شامل ۱ نمیشود.
```js run
alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (هر عدد تصادفی‌ای)
```

`Math.max(a, b, c...)` / `Math.min(a, b, c...)`
: بزرگترین/کوچک‌ترین عدد از آرگومان‌ها را بر‌می‌گرداند
```js run
alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
```

`Math.pow(n, power)`
: عدد `n` را به توان داده شده می‌رساند.
```js run
alert( Math.pow(2, 10) ); // دو به توان ده = 1024
```

توابع و ثوابت بیشتری در شئ `Math` وجود دارد، مثل روابط مثلثات که میتوانید در [docs for the Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) پیدا کنید.
## خلاصه


برای نوشتن اعداد بزرگ

- حرف `"e"` را با تعداد صفرها به انتهای عدد اضافه کنید. مثل: `123e6` که `123` است با ۶ صفر. 
- یک عدد منفی بعد `"e"` باعث تقسیم شدن عدد بر یک با تعداد صفر مشخص شده میشود.

برای سیستم‌های عددی متفاوت:

- میتوان اعداد را مستقیما در فرم پایه۱۶ (`0x`) نوشت، پایه۸ (`0o`) و دودویی (`0b`) نوشت.

- `parseInt(str, base)` یک عدد صحیح را از هر سیستم عددی با پایه‌ی `2 ≤ base ≤ 36` را استخراج می‌کند. 

- `num.toString(base)` یک عدد را به یک رشته‌ی حرفی در سیستم عددی با پایه داده شده تبدیل می‌کند.

برای تبدیل مقادیری مثل `12pt` و `100px` به یک عدد:

- `parseInt/parseFloat` را برای تبدیلات ساده استفاده کنید که یک عدد را از یک رشته‌ی حرفی می‌خواند و سپس مقداری که قبل از بروز خطا خوانده‌ست را برمی‌گرداند.

برای کسرها:

- با کمک `Math.floor`، `Math.ceil`، `Math.trunc`، `Math.round` یا `num.toFixed(precision)` رند کنید.

- به یاد داشته باشید که یک دقت از دست رفته‌ای در حین کار با کسر ها وجود دارد.

توابع ریاضی بیشتر:
- [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) شئ را وقتی به آنها نیاز دارید ببینید. کتابخانه‌ی بسیار کوچکیست اما توابع پایه‌ای را پوشش می‌دهد.

