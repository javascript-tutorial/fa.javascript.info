
# Ø­Ù„Ù‚Ù‡â€ŒÙ¾Ø°ÛŒØ±Ù‡Ø§

Ø´ÛŒØ¡Ù‡Ø§ÛŒ *Ø­Ù„Ù‚Ù‡â€ŒÙ¾Ø°ÛŒØ±* ØªØ¹Ù…ÛŒÙ…ÛŒ Ø§Ø² Ø¢Ø±Ø§ÛŒÙ‡â€ŒÙ‡Ø§ Ù‡Ø³ØªÙ†Ø¯. Ø§ÛŒÙ† Ù…ÙÙ‡ÙˆÙ…ÛŒ Ø§Ø³Øª Ú©Ù‡ Ø¨Ù‡ Ù…Ø§ Ø§Ø¬Ø§Ø²Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ ØªØ§ Ù‡Ø± Ø´ÛŒØ¡Ø§ÛŒ Ø±Ø§ Ø¯Ø± Ø­Ù„Ù‚Ù‡ `for..of` Ù‚Ø§Ø¨Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒÙ….

Ù‚Ø·Ø¹Ø§ Ø¢Ø±Ø§ÛŒÙ‡â€ŒÙ‡Ø§ Ø­Ù„Ù‚Ù‡â€ŒÙ¾Ø°ÛŒØ± Ù‡Ø³ØªÙ†Ø¯. Ø§Ù…Ø§ Ø´ÛŒØ¡Ù‡Ø§ÛŒ Ø¯Ø±ÙˆÙ†â€ŒØ³Ø§Ø®Øª Ø¯ÛŒÚ¯Ø±ÛŒ Ù‡Ù… Ù‡Ø³ØªÙ†Ø¯ Ú©Ù‡ Ø­Ù„Ù‚Ù‡â€ŒÙ¾Ø°ÛŒØ±Ù†Ø¯. Ø¨Ø±Ø§ÛŒ Ù…Ø«Ø§Ù„ØŒ Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ Ù‡Ù… Ø­Ù„Ù‚Ù‡â€ŒÙ¾Ø°ÛŒØ±Ù†Ø¯.

Ø§Ú¯Ø± ÛŒÚ© Ø´ÛŒØ¡ Ø¨Ù‡ Ø·ÙˆØ± ÙÙ†ÛŒ Ø¢Ø±Ø§ÛŒÙ‡ Ù†Ø¨Ø§Ø´Ø¯ØŒ Ø§Ù…Ø§ ÛŒÚ© Ù…Ø¬Ù…ÙˆØ¹Ù‡ (Ù„ÛŒØ³Øª ÛŒØ§ Ø¯Ø³ØªÙ‡) Ø§Ø² Ú†ÛŒØ²Ù‡Ø§ Ø±Ø§ Ù†Ø´Ø§Ù† Ø¯Ù‡Ø¯ØŒ `for..of` ÛŒÚ© Ø³ÛŒÙ†ØªÚ©Ø³ Ø¹Ø§Ù„ÛŒ Ø¨Ø±Ø§ÛŒ Ø­Ù„Ù‚Ù‡â€ŒØ²Ø¯Ù† Ø¯Ø±ÙˆÙ† Ø¢Ù† Ø§Ø³ØªØŒ Ù¾Ø³ Ø¨ÛŒØ§ÛŒÛŒØ¯ Ø¨Ø¨ÛŒÙ†ÛŒÙ… Ú†Ú¯ÙˆÙ†Ù‡ Ú†Ù†ÛŒÙ† Ú©Ø§Ø±ÛŒ Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡ÛŒÙ….


## ÙˆÛŒÚ˜Ú¯ÛŒ Symbol.iterator

Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒÙ… Ø¨Ù‡ Ø±Ø§Ø­ØªÛŒ Ù…ÙÙ‡ÙˆÙ… Ø­Ù„Ù‚Ù‡â€ŒÙ¾Ø°ÛŒØ±Ù‡Ø§ Ø±Ø§ Ø¨Ø§ Ø§ÛŒØ¬Ø§Ø¯ Ø­Ù„Ù‚Ù‡â€ŒÙ¾Ø°ÛŒØ± Ø®ÙˆØ¯Ù…Ø§Ù† Ø¯Ø±Ú© Ú©Ù†ÛŒÙ….

Ø¨Ø±Ø§ÛŒ Ù…Ø«Ø§Ù„ØŒ Ù…Ø§ ÛŒÚ© Ø´ÛŒØ¡ Ø¯Ø§Ø±ÛŒÙ… Ú©Ù‡ Ø¢Ø±Ø§ÛŒÙ‡ Ù†ÛŒØ³ØªØŒ Ø§Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± `for..of` Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³Øª.

Ù…Ø§Ù†Ù†Ø¯ ÛŒÚ© Ø´ÛŒØ¡ `range` Ú©Ù‡ Ø¨Ø§Ø²Ù‡â€ŒØ§ÛŒ Ø§Ø² Ø§Ø¹Ø¯Ø§Ø¯ Ø±Ø§ Ù†Ø´Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯:

```js
let range = {
  from: 1,
  to: 5
};

// :Ú©Ø§Ø± Ú©Ù†Ø¯ for..of Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒÙ… Ú©Ù‡
// for(let num of range) ... num=1,2,3,4,5
```

Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø´ÛŒØ¡ `range` Ø±Ø§ Ø­Ù„Ù‚Ù‡â€ŒÙ¾Ø°ÛŒØ± Ú©Ù†ÛŒÙ… (Ùˆ Ø¨Ù‡ Ø§ÛŒÙ† ØªØ±ØªÛŒØ¨ Ø¨Ú¯Ø°Ø§Ø±ÛŒÙ… `for..of` Ú©Ø§Ø± Ú©Ù†Ø¯) Ù…Ø§ Ù†ÛŒØ§Ø² Ø¯Ø§Ø±ÛŒÙ… Ú©Ù‡ ÛŒÚ© Ù…ØªØ¯ Ø¨Ù‡ Ø§Ø³Ù… `Symbol.iterator` Ø±Ø§ Ø¨Ù‡ Ø´ÛŒØ¡ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒÙ… ( ÛŒÚ© Ø³Ù…Ø¨Ù„ Ø®Ø§Øµ Ø¯Ø±ÙˆÙ† Ø³Ø§Ø®Øª Ú©Ù‡ ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ú©Ø§Ø± Ø§Ø³Øª).

1. Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ `for..of` Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŒ Ù…ØªØ¯ Ø±Ø§ ÛŒÚ© Ø¨Ø§Ø± ØµØ¯Ø§ Ù…ÛŒâ€ŒØ²Ù†Ø¯ (ÛŒØ§ Ø§Ú¯Ø± Ù¾ÛŒØ¯Ø§ Ù†Ø´ÙˆØ¯ Ø§Ø±ÙˆØ± Ù…ÛŒâ€ŒØ¯Ù‡Ø¯). Ù…ØªØ¯ Ø¨Ø§ÛŒØ¯ ÛŒÚ© *Ø­Ù„Ù‚Ù‡â€ŒØ²Ù†Ù†Ø¯Ù‡* Ø±Ø§ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯ -- Ø´ÛŒØ¡Ø§ÛŒ Ú©Ù‡ Ù…ØªØ¯ `next` Ø±Ø§ Ø¯Ø§Ø±Ø¯.
2. Ù‡Ù…ÛŒÙ†Ø·ÙˆØ± Ø±Ùˆ Ø¨Ù‡ Ø¬Ù„ÙˆØŒ `for..of` *ØªÙ†Ù‡Ø§ Ø¨Ø§ Ø´ÛŒØ¡ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù‡ Ø´Ø¯Ù‡* Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
3. Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ `for..of` Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø¹Ø¯ÛŒ Ø±Ø§ Ù†ÛŒØ§Ø² Ø¯Ø§Ø±Ø¯ØŒ Ø±ÙˆÛŒ Ø¢Ù† Ø´ÛŒØ¡ `next()` Ø±Ø§ ØµØ¯Ø§ Ù…ÛŒâ€ŒØ²Ù†Ø¯.
4. Ù†ØªÛŒØ¬Ù‡ `next()` Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ Ø´Ú©Ù„ `{done: Boolean, value: any}` Ø¨Ø§Ø´Ø¯ Ú©Ù‡ `done=true` Ø¨Ù‡ Ù…Ø¹Ù†ÛŒ Ù¾Ø§ÛŒØ§Ù† Ø­Ù„Ù‚Ù‡â€ŒØ²Ø¯Ù† Ø§Ø³ØªØŒ Ø¯Ø± ØºÛŒØ± Ø§ÛŒÙ† ØµÙˆØ±Øª `value` Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø¹Ø¯ÛŒ Ø®ÙˆØ§Ù‡Ø¯ Ø¨ÙˆØ¯.

Ø§ÛŒÙ†Ø¬Ø§ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ Ø±Ø§ Ø¨Ø±Ø§ÛŒ `range` Ø¨Ù‡ Ù‡Ù…Ø±Ø§Ù‡ Ø§Ø¸Ù‡Ø§Ø±Ø§Øª Ø¯Ø§Ø±ÛŒÙ…:

```js run
let range = {
  from: 1,
  to: 5
};

// 1. Ø§Ø¨ØªØ¯Ø§ Ø§ÛŒÙ† Ù…ØªØ¯ ØµØ¯Ø§ Ø²Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ for..of Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø²
range[Symbol.iterator] = function() {

  // :Ø§ÛŒÙ† Ù…ØªØ¯ Ø´ÛŒØ¡ Ø­Ù„Ù‚Ù‡â€ŒØ²Ù†Ù†Ø¯Ù‡ Ø±Ø§ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯...
  // 2. ÙÙ‚Ø· Ø¨Ø§ Ø§ÛŒÙ† Ø­Ù„Ù‚Ù‡â€ŒØ²Ù†Ù†Ø¯Ù‡ Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯ØŒ Ú©Ù‡ Ø§Ø² Ø¢Ù† Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø¹Ø¯ÛŒ Ø±Ø§ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…ÛŒâ€ŒÚ©Ù†Ø¯ for..of ØŒÙ‡Ù…ÛŒÙ†Ø·ÙˆØ± Ø±Ùˆ Ø¨Ù‡ Ø¬Ù„Ùˆ
  return {
    current: this.from,
    last: this.to,      

    // 3. ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯ for..of Ø¯Ø± Ù‡Ø± Ø¯ÙˆØ± Ø­Ù„Ù‚Ù‡ ØªÙˆØ³Ø· next()
    next() {
      // 4. Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯ {done:..., value:...} Ø§ÛŒÙ† Ù…ØªØ¯ Ø¨Ø§ÛŒØ¯ Ù…Ù‚Ø¯Ø§Ø± Ø±Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† ÛŒÚ© Ø´ÛŒØ¡
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// !Ø­Ø§Ù„Ø§ Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
```

Ù„Ø·ÙØ§ Ø®Ø§ØµÛŒØª Ø§ØµÙ„ÛŒ Ø­Ù„Ù‚Ù‡â€ŒÙ¾Ø°ÛŒØ±Ù‡Ø§ Ø±Ø§ Ø¯Ø± Ù†Ø¸Ø± Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒØ¯: ØªÙÚ©ÛŒÚ© ÙˆØ¸Ø§ÛŒÙ.

- Ø´ÛŒØ¡ `range` Ø¨Ù‡ Ø®ÙˆØ¯ÛŒ Ø®ÙˆØ¯ Ø¯Ø§Ø±Ø§ÛŒ Ù…ØªØ¯ `next()` Ù†ÛŒØ³Øª.
- Ø¨Ù‡ Ø¬Ø§ÛŒ Ø¢Ù†ØŒ Ø´ÛŒØ¡ Ø¯ÛŒÚ¯Ø±ÛŒ Ú©Ù‡ Ø¨Ù‡ Ø¢Ù† Â«Ø­Ù„Ù‚Ù‡â€ŒØ²Ù†Ù†Ø¯Ù‡Â» Ù‡Ù… Ù…ÛŒâ€ŒÚ¯ÙˆÛŒÙ†Ø¯ Ø¨Ø§ ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ `range[Symbol.iterator]()` Ùˆ Ù…ØªØ¯ `next()` Ø¢Ù†ØŒ Ù…Ù‚Ø¯Ø§Ø±Ù‡Ø§ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø­Ù„Ù‚Ù‡â€ŒØ²Ø¯Ù† Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.

Ø¨Ù†Ø§Ø¨Ø±Ø§ÛŒÙ†ØŒ Ø´ÛŒØ¡ Ø­Ù„Ù‚Ù‡â€ŒØ²Ù†Ù†Ø¯Ù‡ Ø§Ø² Ø´ÛŒØ¡Ø§ÛŒ Ú©Ù‡ Ø¯Ø± Ø¢Ù† Ø­Ù„Ù‚Ù‡ Ù…ÛŒâ€ŒØ²Ù†Ø¯ Ø¬Ø¯Ø§ Ø§Ø³Øª.

Ø¨Ù‡ Ø·ÙˆØ± ÙÙ†ÛŒØŒ Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒÙ… Ø¢Ù†Ù‡Ø§ Ø±Ø§ ØªØ±Ú©ÛŒØ¨ Ú©Ù†ÛŒÙ… Ùˆ Ø§Ø² Ø®ÙˆØ¯ `range` Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø­Ù„Ù‚Ù‡â€ŒØ²Ù†Ù†Ø¯Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒÙ… ØªØ§ Ú©Ø¯ Ø³Ø§Ø¯Ù‡â€ŒØªØ± Ø´ÙˆØ¯.

Ù…Ø§Ù†Ù†Ø¯ Ø§ÛŒÙ†:

```js run
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
```

Ø­Ø§Ù„Ø§ `range[Symbol.iterator]()` Ø®ÙˆØ¯ Ø´ÛŒØ¡ `range` Ø±Ø§ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯: Ø§ÛŒÙ† Ø´ÛŒØ¡ Ø¯Ø§Ø±Ø§ÛŒ Ù…ØªØ¯ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² `next()` Ø§Ø³Øª Ùˆ ÙØ±Ø§ÛŒÙ†Ø¯ Ú©Ù†ÙˆÙ†ÛŒ Ø­Ù„Ù‚Ù‡â€ŒØ²Ø¯Ù† Ø±Ø§ Ø¯Ø± `this.current` Ø¨Ù‡ Ø®Ø§Ø·Ø± Ù…ÛŒâ€ŒØ³Ù¾Ø§Ø±Ø¯. Ú©ÙˆØªØ§Ù‡â€ŒØªØ± Ø§Ø³ØªØŸ Ø¨Ù„Ù‡. Ùˆ Ú¯Ø§Ù‡ÛŒ Ø§ÙˆÙ‚Ø§Øª Ø§ÛŒÙ† Ù‡Ù… Ø®ÙˆØ¨ Ø§Ø³Øª.

Ø§Ù…Ø§ Ø§Ù…ØªÛŒØ§Ø²ÛŒ Ù…Ù†ÙÛŒ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯: Ø­Ø§Ù„Ø§ ØºÛŒØ± Ù…Ù…Ú©Ù† Ø§Ø³Øª Ú©Ù‡ Ø¯Ùˆ Ø­Ù„Ù‚Ù‡ `for..of` Ø¨ØªÙˆØ§Ù†Ù†Ø¯ Ø¨Ù‡ Ø·ÙˆØ± Ù‡Ù…Ø²Ù…Ø§Ù† Ø¯Ø± Ø´ÛŒØ¡ Ø­Ù„Ù‚Ù‡ Ø¨Ø²Ù†Ù†Ø¯ Ú†ÙˆÙ† Ø¢Ù†Ù‡Ø§ ÙˆØ¶Ø¹ÛŒØª Ø­Ù„Ù‚Ù‡â€ŒØ²Ø¯Ù† Ø±Ø§ Ø¨Ù‡ Ø§Ø´ØªØ±Ø§Ú© Ù…ÛŒâ€ŒÚ¯Ø°Ø§Ø±Ù†Ø¯ Ùˆ Ø¢Ù† Ù‡Ù… Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ Ø§ÛŒÙ†Ú©Ù‡ ØªÙ†Ù‡Ø§ ÛŒÚ© Ø­Ù„Ù‚Ù‡â€ŒØ²Ù†Ù†Ø¯Ù‡ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯ -- Ø®ÙˆØ¯ Ø´ÛŒØ¡Ù‡Ø§. Ø§Ù…Ø§ Ø¯Ùˆ for-of Ù‡Ù…Ø²Ù…Ø§Ù† Ø¨Ù‡ Ù†Ø¯Ø±Øª Ù¾ÛŒØ´ Ù…ÛŒâ€ŒØ¢ÛŒØ¯ØŒ Ø­ØªÛŒ Ø¯Ø± Ø³Ù†Ø§Ø±ÛŒÙˆÙ‡Ø§ÛŒ async (Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ).

```smart header="Ø­Ù„Ù‚Ù‡â€ŒØ²Ù†Ù†Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨ÛŒâ€ŒÙ†Ù‡Ø§ÛŒØª"
Ø­Ù„Ù‚Ù‡â€ŒØ²Ù†Ù†Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨ÛŒâ€ŒÙ†Ù‡Ø§ÛŒØª Ù‡Ù… Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø§ÛŒØ¬Ø§Ø¯ Ø´ÙˆÙ†Ø¯. Ø¨Ø±Ø§ÛŒ Ù…Ø«Ù„ØŒ `range` Ø¨Ù‡ Ø§Ø²Ø§ÛŒ `range.to = Infinity` Ø¨ÛŒâ€ŒÙ†Ù‡Ø§ÛŒØª Ù…ÛŒâ€ŒØ´ÙˆØ¯. ÛŒØ§ Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒÙ… ÛŒÚ© Ø´ÛŒØ¡ Ø­Ù„Ù‚Ù‡â€ŒÙ¾Ø°ÛŒØ± Ø±Ø§ Ú©Ù‡ ÛŒÚ© Ø¯Ù†Ø¨Ø§Ù„Ù‡ Ø¨ÛŒâ€ŒÙ†Ù‡Ø§ÛŒØª Ø§Ø² Ø´Ø¨Ù‡ Ø§Ø¹Ø¯Ø§Ø¯ Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ø¨Ø³Ø§Ø²ÛŒÙ…. Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù…ÙÛŒØ¯ Ù‡Ù… Ø¨Ø§Ø´Ø¯.

Ù‡ÛŒÚ† Ù…Ø­Ø¯ÙˆØ¯ÛŒØªÛŒ Ø¨Ø±Ø§ÛŒ `next` ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø§ÛŒÙ† Ù…ØªØ¯ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù…Ù‚Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ± Ùˆ Ø¨ÛŒØ´ØªØ±ÛŒ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯ Ùˆ Ø§ÛŒÙ† Ø¹Ø§Ø¯ÛŒ Ø§Ø³Øª.

Ù‚Ø·Ø¹Ø§ØŒ Ø­Ù„Ù‚Ù‡ `for..of` Ø¯Ø±ÙˆÙ† Ú†Ù†ÛŒÙ† Ø­Ù„Ù‚Ù‡â€ŒÙ¾Ø°ÛŒØ±ÛŒ Ù¾Ø§ÛŒØ§Ù†â€ŒÙ†Ø§Ù¾Ø°ÛŒØ± Ø®ÙˆØ§Ù‡Ø¯ Ø¨ÙˆØ¯. Ø§Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒÙ… Ø¢Ù† Ø±Ø§ Ù‡Ù…ÛŒØ´Ù‡ Ø¨Ø§ `break` Ù…ØªÙˆÙ‚Ù Ú©Ù†ÛŒÙ….
```


## String is iterable

Arrays and strings are most widely used built-in iterables.

For a string, `for..of` loops over its characters:

```js run
for (let char of "test") {
  // triggers 4 times: once for each character
  alert( char ); // t, then e, then s, then t
}
```

And it works correctly with surrogate pairs!

```js run
let str = 'ğ’³ğŸ˜‚';
for (let char of str) {
    alert( char ); // ğ’³, and then ğŸ˜‚
}
```

## Calling an iterator explicitly

For deeper understanding, let's see how to use an iterator explicitly.

We'll iterate over a string in exactly the same way as `for..of`, but with direct calls. This code creates a string iterator and gets values from it "manually":

```js run
let str = "Hello";

// does the same as
// for (let char of str) alert(char);

*!*
let iterator = str[Symbol.iterator]();
*/!*

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // outputs characters one by one
}
```

That is rarely needed, but gives us more control over the process than `for..of`. For instance, we can split the iteration process: iterate a bit, then stop, do something else, and then resume later.

## Iterables and array-likes [#array-like]

Two official terms look similar, but are very different. Please make sure you understand them well to avoid the confusion.

- *Iterables* are objects that implement the `Symbol.iterator` method, as described above.
- *Array-likes* are objects that have indexes and `length`, so they look like arrays.

When we use JavaScript for practical tasks in a browser or any other environment, we may meet objects that are iterables or array-likes, or both.

For instance, strings are both iterable (`for..of` works on them) and array-like (they have numeric indexes and `length`).

But an iterable may be not array-like. And vice versa an array-like may be not iterable.

For example, the `range` in the example above is iterable, but not array-like, because it does not have indexed properties and `length`.

And here's the object that is array-like, but not iterable:

```js run
let arrayLike = { // has indexes and length => array-like
  0: "Hello",
  1: "World",
  length: 2
};

*!*
// Error (no Symbol.iterator)
for (let item of arrayLike) {}
*/!*
```

Both iterables and array-likes are usually *not arrays*, they don't have `push`, `pop` etc. That's rather inconvenient if we have such an object and want to work with it as with an array. E.g. we would like to work with `range` using array methods. How to achieve that?

## Array.from

There's a universal method [Array.from](mdn:js/Array/from) that takes an iterable or array-like value and makes a "real" `Array` from it. Then we can call array methods on it.

For instance:

```js run
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

*!*
let arr = Array.from(arrayLike); // (*)
*/!*
alert(arr.pop()); // World (method works)
```

`Array.from` at the line `(*)` takes the object, examines it for being an iterable or array-like, then makes a new array and copies all items to it.

The same happens for an iterable:

```js
// assuming that range is taken from the example above
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (array toString conversion works)
```

The full syntax for `Array.from` also allows us to provide an optional "mapping" function:
```js
Array.from(obj[, mapFn, thisArg])
```

The optional second argument `mapFn` can be a function that will be applied to each element before adding it to the array, and `thisArg` allows us to set `this` for it.

For instance:

```js
// assuming that range is taken from the example above

// square each number
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
```

Here we use `Array.from` to turn a string into an array of characters:

```js run
let str = 'ğ’³ğŸ˜‚';

// splits str into array of characters
let chars = Array.from(str);

alert(chars[0]); // ğ’³
alert(chars[1]); // ğŸ˜‚
alert(chars.length); // 2
```

Unlike `str.split`, it relies on the iterable nature of the string and so, just like `for..of`, correctly works with surrogate pairs.

Technically here it does the same as:

```js run
let str = 'ğ’³ğŸ˜‚';

let chars = []; // Array.from internally does the same loop
for (let char of str) {
  chars.push(char);
}

alert(chars);
```

...But it is shorter.    

We can even build surrogate-aware `slice` on it:

```js run
function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = 'ğ’³ğŸ˜‚ğ©·¶';

alert( slice(str, 1, 3) ); // ğŸ˜‚ğ©·¶

// the native method does not support surrogate pairs
alert( str.slice(1, 3) ); // garbage (two pieces from different surrogate pairs)
```


## Summary

Objects that can be used in `for..of` are called *iterable*.

- Technically, iterables must implement the method named `Symbol.iterator`.
    - The result of `obj[Symbol.iterator]()` is called an *iterator*. It handles further iteration process.
    - An iterator must have the method named `next()` that returns an object `{done: Boolean, value: any}`, here `done:true` denotes the end of the iteration process, otherwise the `value` is the next value.
- The `Symbol.iterator` method is called automatically by `for..of`, but we also can do it directly.
- Built-in iterables like strings or arrays, also implement `Symbol.iterator`.
- String iterator knows about surrogate pairs.


Objects that have indexed properties and `length` are called *array-like*. Such objects may also have other properties and methods, but lack the built-in methods of arrays.

If we look inside the specification -- we'll see that most built-in methods assume that they work with iterables or array-likes instead of "real" arrays, because that's more abstract.

`Array.from(obj[, mapFn, thisArg])` makes a real `Array` from an iterable or array-like `obj`, and we can then use array methods on it. The optional arguments `mapFn` and `thisArg` allow us to apply a function to each item.
